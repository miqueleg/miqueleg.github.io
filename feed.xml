<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://miqueleg.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://miqueleg.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-05-24T09:32:56+00:00</updated><id>https://miqueleg.github.io/feed.xml</id><title type="html">Dr. Miquel Estévez-Gay - Protein Engineering</title><subtitle>Postdoctoral researcher in Computational Protein Engineeering and Molecular Dynamics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Protonation Optimizer</title><link href="https://miqueleg.github.io/blog/2025/QMMESP/" rel="alternate" type="text/html" title="Protonation Optimizer"/><published>2025-05-23T18:15:00+00:00</published><updated>2025-05-23T18:15:00+00:00</updated><id>https://miqueleg.github.io/blog/2025/QMMESP</id><content type="html" xml:base="https://miqueleg.github.io/blog/2025/QMMESP/"><![CDATA[<h1 id="qmmesp---qmmm-environment-aware-resp-charge-derivation">QMMESP - QM/MM Environment-aware RESP Charge Derivation</h1> <p>A Python script for computing environment-aware RESP charges of ligands using QM/MM calculations with electrostatic embedding. The script supports both ORCA and PySCF as quantum mechanics engines and uses Multiwfn for RESP charge fitting.</p> <h2 id="table-of-contents">Table of Contents</h2> <ul> <li><a href="#overview">Overview</a></li> <li><a href="#features">Features</a></li> <li><a href="#installation">Installation</a></li> <li><a href="#dependencies">Dependencies</a></li> <li><a href="#usage">Usage</a></li> <li><a href="#input-files">Input Files</a></li> <li><a href="#output-files">Output Files</a></li> <li><a href="#examples">Examples</a></li> <li><a href="#citation">Citation</a></li> <li><a href="#license">License</a></li> </ul> <h2 id="overview">Overview</h2> <p>QMMESP calculates RESP (Restrained Electrostatic Potential) charges for ligands while considering their local protein environment through QM/MM calculations. Unlike traditional gas-phase RESP calculations, this approach:</p> <ul> <li><strong>Includes environmental effects</strong>: The ligand is treated quantum mechanically while the protein environment is modeled with classical force fields</li> <li><strong>Uses electrostatic embedding</strong>: Point charges from the MM region polarize the QM wavefunction</li> <li><strong>Supports multiple QM engines</strong>: Choose between PySCF (default) or ORCA for quantum calculations</li> <li><strong>Automated workflow</strong>: From prepared MD structures to final RESP charges in one step</li> </ul> <h2 id="features">Features</h2> <ul> <li>✅ <strong>Dual QM Engine Support</strong>: PySCF (default) or ORCA</li> <li>✅ <strong>Environment-aware Charges</strong>: QM/MM approach includes protein effects</li> <li>✅ <strong>AMBER Integration</strong>: Direct prepi file updates for MD simulations</li> </ul> <h2 id="installation">Installation</h2> <h3 id="1-clone-the-repository">1. Clone the Repository</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/miqueleg/QMMESP.git
cd QMMESP
</code></pre></div></div> <h3 id="2-set-up-python-environment">2. Set Up Python Environment</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#Create conda environment
conda create -n qmmesp python=3.13
conda activate qmmesp

#Install required packages
pip install numpy mdtraj
</code></pre></div></div> <h3 id="3-install-dependencies">3. Install Dependencies</h3> <p>See <a href="#dependencies">Dependencies</a> section for detailed installation instructions.</p> <h2 id="dependencies">Dependencies</h2> <h3 id="required-software">Required Software</h3> <table> <thead> <tr> <th>Software</th> <th>Purpose</th> <th>Installation</th> </tr> </thead> <tbody> <tr> <td><strong>ASH</strong></td> <td>QM/MM calculations</td> <td><code class="language-plaintext highlighter-rouge">python -m pip install git+https://github.com/RagnarB83/ash.git</code></td> </tr> <tr> <td><strong>PySCF</strong></td> <td>QM engine (default)</td> <td><code class="language-plaintext highlighter-rouge">pip install --prefer-binary pyscf</code></td> </tr> <tr> <td><strong>ORCA</strong></td> <td>QM engine (optional)</td> <td>Download from <a href="https://orcaforum.kofo.mpg.de">ORCA website</a></td> </tr> <tr> <td><strong>Multiwfn</strong></td> <td>RESP fitting</td> <td>Download from <a href="http://sobereva.com/multiwfn/">Multiwfn website</a></td> </tr> <tr> <td><strong>OpenMM</strong></td> <td>MM calculations</td> <td><code class="language-plaintext highlighter-rouge">conda install -c conda-forge openmm</code></td> </tr> </tbody> </table> <h3 id="environment-variables">Environment Variables</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#Add to your ~/.bashrc or ~/.zshrc
export Multiwfnpath="/path/to/multiwfn"
export ORCADIR="/path/to/orca" # Only if using ORCA
</code></pre></div></div> <h2 id="usage">Usage</h2> <h3 id="basic-command">Basic Command</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python QMMESP.py --pdb complex.pdb --prmtop complex.prmtop --inpcrd complex.inpcrd --resid 1
</code></pre></div></div> <h3 id="complete-example">Complete Example</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python QMMESP.py
--pdb solvated_complex.pdb
--prmtop complex.prmtop
--inpcrd complex.inpcrd
--prepi ligand.prepi
--resid 285
--charge 0
--functional HF
--basis 6-31G*
--qm_engine pyscf
--output resp_results
--numcores 4
</code></pre></div></div> <h3 id="command-line-arguments">Command Line Arguments</h3> <table> <thead> <tr> <th>Argument</th> <th>Required</th> <th>Default</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">--pdb</code></td> <td>✅</td> <td>-</td> <td>Input PDB file (solvated complex)</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--prmtop</code></td> <td>✅</td> <td>-</td> <td>AMBER topology file</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--inpcrd</code></td> <td>✅</td> <td>-</td> <td>AMBER coordinate file</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--resid</code></td> <td>✅</td> <td>-</td> <td>Residue ID of the ligand</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--prepi</code></td> <td>❌</td> <td>-</td> <td>Original prepi file for charge updates</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--charge</code></td> <td>❌</td> <td>0</td> <td>Net charge of the QM region</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--mult</code></td> <td>❌</td> <td>1</td> <td>Multiplicity of the QM region</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--functional</code></td> <td>❌</td> <td>HF</td> <td>DFT functional (HF, B3LYP, PW6B95, etc.)</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--basis</code></td> <td>❌</td> <td>6-31G*</td> <td>Basis set</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--qm_engine</code></td> <td>❌</td> <td>pyscf</td> <td>QM engine: <code class="language-plaintext highlighter-rouge">pyscf</code> or <code class="language-plaintext highlighter-rouge">orca</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--output</code></td> <td>❌</td> <td>qmmm_resp</td> <td>Output directory</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--numcores</code></td> <td>❌</td> <td>8</td> <td>Number of CPU cores</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--multiwfnpath</code></td> <td>❌</td> <td>$Multiwfnpath</td> <td>Path to Multiwfn installation</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--orcadir</code></td> <td>❌</td> <td>$ORCADIR</td> <td>Path to ORCA installation</td> </tr> </tbody> </table> <h2 id="input-files">Input Files</h2> <h3 id="required-files">Required Files</h3> <ol> <li><strong>PDB File</strong> (<code class="language-plaintext highlighter-rouge">--pdb</code>): Solvated protein-ligand complex <ul> <li>Must contain properly numbered residues</li> <li>Ligand should have a unique residue name</li> <li>Can include crystallographic waters</li> </ul> </li> <li><strong>Topology File</strong> (<code class="language-plaintext highlighter-rouge">--prmtop</code>): AMBER parameter/topology file <ul> <li>Generated using tleap with appropriate force fields</li> <li>Must include parameters for all system components</li> </ul> </li> <li><strong>Coordinate File</strong> (<code class="language-plaintext highlighter-rouge">--inpcrd</code>): AMBER coordinate file <ul> <li>Matching the topology file</li> <li>Typically from energy minimization or equilibration</li> </ul> </li> </ol> <h3 id="optional-files">Optional Files</h3> <ol> <li><strong>Prepi File</strong> (<code class="language-plaintext highlighter-rouge">--prepi</code>): AMBER residue library file <ul> <li>Will be updated with new RESP charges</li> <li>Useful for subsequent MD simulations</li> </ul> </li> </ol> <h2 id="output-files">Output Files</h2> <h3 id="generated-files">Generated Files</h3> <table> <thead> <tr> <th>File</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">substrate_[engine]_charges.txt</code></td> <td>RESP charges for each atom</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">esp.molden</code></td> <td>Molecular orbital file for ESP analysis</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">[residue]_[engine].prepi</code></td> <td>Updated prepi file with RESP charges</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">multiwfn.log</code></td> <td>Multiwfn calculation log</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">multiwfn_input.txt</code></td> <td>Input file for Multiwfn</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">esp.chg</code></td> <td>Raw charge data from Multiwfn</td> </tr> </tbody> </table> <h2 id="examples">Examples</h2> <h3 id="example-1-basic-resp-calculation-with-pyscf">Example 1: Basic RESP Calculation with PySCF</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python QMMESP.py
--pdb protein_ligand.pdb
--prmtop system.prmtop
--inpcrd system.inpcrd
--resid 500
--charge -1
</code></pre></div></div> <h3 id="example-2-high-level-resp2-like-charges-with-orca">Example 2: High-Level RESP2-like Charges with ORCA</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python QMMESP.py
--pdb complex_solvated.pdb
--prmtop complex.prmtop
--inpcrd complex.inpcrd
--resid 285
--functional PW6B95
--basis aug-cc-pVDZ
--qm_engine orca
--numcores 16
--output resp2_results
</code></pre></div></div> <h3 id="example-3-update-prepi-file-for-md">Example 3: Update Prepi File for MD</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python QMMESP.py
--pdb equilibrated.pdb
--prmtop system.prmtop
--inpcrd system.inpcrd
--prepi original_ligand.prepi
--resid 1
--functional B3LYP
--basis 6-31G*
--output updated_params
</code></pre></div></div> <h3 id="performance-tips">Performance Tips</h3> <ul> <li><strong>Use PySCF for routine calculations</strong>: Generally faster and more stable</li> <li><strong>Optimize core usage</strong>: Start with 4-8 cores, increase for large systems</li> <li><strong>Monitor memory usage</strong>: Large basis sets may require significant RAM</li> <li><strong>Use recomended basis sets</strong>: HF/6-31G* for ff14SB, PW6B95/aug-cc-pVDZ for ff19SB</li> </ul> <h2 id="method-details">Method Details</h2> <h3 id="qmmm-setup">QM/MM Setup</h3> <ul> <li><strong>QM Region</strong>: Ligand of interest (specified by residue ID)</li> <li><strong>MM Region</strong>: Protein, water, and ions</li> <li><strong>Embedding</strong>: Electrostatic (point charges polarize QM wavefunction)</li> <li><strong>Boundary</strong>: Automatic detection based on residue boundaries</li> </ul> <h3 id="resp-fitting">RESP Fitting</h3> <ol> <li><strong>ESP Generation</strong>: Quantum mechanical electrostatic potential on molecular surface</li> <li><strong>Grid Points</strong>: Multiwfn automatically generates fitting points</li> <li><strong>Restraints</strong>: Standard RESP restraints applied (0.0005 au for C,N,O,S; 0.001 au for H)</li> <li><strong>Fitting</strong>: Two-stage RESP procedure with buried carbon restraints</li> </ol> <h3 id="recommended-methods">Recommended Methods</h3> <table> <thead> <tr> <th>Purpose</th> <th>Functional</th> <th>Basis Set</th> <th>Notes</th> </tr> </thead> <tbody> <tr> <td><strong>RESP1-like</strong></td> <td>HF</td> <td>6-31G*</td> <td>Traditional RESP charges</td> </tr> <tr> <td><strong>RESP2-like</strong></td> <td>PW6B95</td> <td>aug-cc-pVDZ</td> <td>Modern improved method</td> </tr> </tbody> </table> <h2 id="citation">Citation</h2> <p>If you use this software in your research, please cite:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@software{qmmesp2025,
author = {Miquel Estévez-Gay},
title = {QMMESP: Environment-aware RESP charge derivation using QM/MM},
url = {https://github.com/miqueleg/QMMESP},
year = {2025}
}
</code></pre></div></div> <h3 id="related-publications">Related Publications</h3> <ul> <li>Bayly, C. I.; Cieplak, P.; Cornell, W.; Kollman, P. A. J. Phys. Chem. 1993, 97, 10269-10280. (Original RESP method)</li> <li>Schauperl, M.; Nerenberg, P. S.; Jang, H.; et al. J. Chem. Theory Comput. 2020, 16, 7044-7060. (RESP2 method)</li> </ul> <h2 id="contributing">Contributing</h2> <p>Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.</p> <h2 id="license">License</h2> <p>This project is licensed under the MIT License - see the <a href="LICENSE">LICENSE</a> file for details.</p> <h2 id="support">Support</h2> <p>For questions, issues, or suggestions:</p> <ol> <li><strong>GitHub Issues</strong>: <a href="https://github.com/miqueleg/QMMESP/issues">Create an issue</a></li> <li><strong>Email</strong>: [Your email if you want to provide it]</li> <li><strong>ORCA Forum</strong>: For ORCA-specific questions</li> <li><strong>PySCF Community</strong>: For PySCF-related issues</li> <li><strong>ASH GitHub</strong>: For ASH-related issues</li> </ol> <hr/> <p><strong>Note</strong>: This software is provided as-is for research purposes. Always validate results against experimental data or established benchmarks for your specific systems.</p>]]></content><author><name></name></author><category term="script"/><category term="python"/><category term="RESP"/><category term="charges"/><category term="calculation"/><category term="for"/><category term="MD"/><summary type="html"><![CDATA[Announcement of QMMESP.py]]></summary></entry><entry><title type="html">Protonation Optimizer</title><link href="https://miqueleg.github.io/blog/2025/Protonation-Optimizer/" rel="alternate" type="text/html" title="Protonation Optimizer"/><published>2025-05-22T18:00:00+00:00</published><updated>2025-05-22T18:00:00+00:00</updated><id>https://miqueleg.github.io/blog/2025/Protonation-Optimizer</id><content type="html" xml:base="https://miqueleg.github.io/blog/2025/Protonation-Optimizer/"><![CDATA[<p>I’m excited to share my latest computational tool for the molecular modeling community: Protonation Optimizer - a (SemiEmpirical) quantum mechanics-based solution for determining optimal amino acid protonation states in protein structures!</p> <p>🔬 Why it matters: Accurate protonation states are critical for reliable molecular dynamics (MD) simulations, yet they’re often overlooked. Incorrect assignments can lead to artifacts or misleading results, particularly with histidine residues that can exist in multiple tautomeric forms for the same pH conditions.</p> <h4 id="-key-features">⚡ Key features:</h4> <p>Integrates PropKa3 for pKa predictions and initial state assignments. Employs xTB semi-empirical quantum chemistry calculations to determine energetically favorable protonation states. Handles both HID (δ-protonated) and HIE (ε-protonated) histidine tautomers with QM accuracy. Provides detailed energy reports and automatically generates optimized PDB files.</p> <h3 id="-check-it-out-protonation-optimizer">🔗 Check it out: <a href="https://github.com/miqueleg/protonation-optimizer/tree/main" title="Protonation State Optimizer">Protonation-Optimizer</a></h3> <p>Feel free to use it and let me know how it went!</p> <h1 id="protonation-state-optimizer">Protonation State Optimizer</h1> <p>A quantum mechanics-based tool for determining optimal aminoacidic protonation states (focusing on Histidines) in protein structures for molecular dynamics simulations.</p> <h2 id="description">Description</h2> <p>This tool analyzes protein structures and determines the energetically favorable protonation state for each histidine residue using the xTB semi-empirical quantum chemistry method (HID/HIE). It accurately handles the two neutral tautomeric forms of histidine by:</p> <ol> <li>Checks pKa using the PropKa3 tool. It determines HIP protonation based on pKa</li> <li>Extracting the local environment around each histidine residue</li> <li>Generating both HID (delta-protonated) and HIE (epsilon-protonated) tautomers</li> <li>Special handling of charged residues (ASP, GLU, LYS, ARG) with proper proton positioning</li> <li>Running quantum mechanical energy calculations on each tautomer</li> <li>Comparing energies to determine the optimal protonation state</li> </ol> <p>This tool is particularly useful for preparing protein structures for molecular dynamics simulations where histidine protonation can significantly impact results.</p> <h2 id="dependencies">Dependencies</h2> <h3 id="python-packages">Python Packages</h3> <ul> <li>NumPy</li> <li>Pandas</li> <li>MDTraj</li> <li>BioPython (Bio.PDB)</li> <li>Tabulate</li> </ul> <h3 id="external-software">External Software</h3> <ul> <li>Open Babel (for hydrogen placement)</li> <li>xTB (for quantum mechanical calculations)</li> <li>PropKa3</li> </ul> <h2 id="installation">Installation</h2> <ol> <li> <p>Install the required Python packages:</p> </li> <li> <p>Install Open Babel:</p> </li> <li> <p>Install xTB:</p> </li> <li> <p>Install PropKa3</p> </li> <li> <p>Clone the repository:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/miqueleg/protonation-optimizer
</code></pre></div> </div> </li> </ol> <h2 id="usage">Usage</h2> <p>Basic usage:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python protonation_optimizer.py input.pdb output.pdb
</code></pre></div></div> <p>With custom environment cutoff (default is 5.0 Å):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python protonation_optimizer.py input.pdb output.pdb --cutoff 6.0
</code></pre></div></div> <p>Changing Optimization level and Solvent (default loose and ether) :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python protonation_optimizer.py input.pdb output.pdb --xtbopt crude --solvent water
</code></pre></div></div> <p>Using Single Point calculations instead of Optimization [Faster but less precise] (default opt) :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python protonation_optimizer.py input.pdb output.pdb --mode SP
</code></pre></div></div> <p>This will:</p> <ol> <li>Run PropKa3 and determine initial protonations</li> <li>Find all histidine residues in <code class="language-plaintext highlighter-rouge">protein.pdb</code></li> <li>For each histidine, extract a 5.0 Å environment</li> <li>Create both HID and HIE tautomers with proper hydrogen placement</li> <li>Run xTB optimization or single point calculations on each tautomer</li> <li>Determine the optimal protonation state based on energy</li> <li>Generate a detailed report table of the analysis</li> </ol> <h2 id="output-files">Output Files</h2> <p>The tool generates several outputs:</p> <ul> <li>An optimized PDB file with the computed protonation states of the AminoAcids in your protein</li> <li>A CSV file with energy results for each histidine</li> <li>A detailed text report of the analysis</li> <li>xTB log files for each calculation in an <code class="language-plaintext highlighter-rouge">xtb_logs</code> directory</li> </ul> <h2 id="special-features">Special Features</h2> <ul> <li><strong>Charged Residue Handling</strong>: It handles ASP, GLU, LYS, and ARG by pKa/pH comparison using PropKa3</li> <li><strong>Constraint-based Optimization</strong>: Allows hydrogen atoms to relax during energy calculations while keeping heavy atoms fixed</li> </ul> <h2 id="limitations">Limitations</h2> <ul> <li>Only handles the two neutral tautomers via QM (HID and HIE), not the protonated form (HIP). The latest is only determined via pKa calculation</li> <li>Processes each histidine independently; for histidines in close proximity, results may not capture cooperative effects (yet)</li> </ul> <h2 id="citing-this-software">Citing This Software</h2> <p>If you use this tool in your research, please cite it as:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Estévez-Gay, M. (2025). Protonation State Optimizer.
GitHub repository: https://github.com/miqueleg/protonation-optimizer
</code></pre></div></div>]]></content><author><name></name></author><category term="script"/><category term="python"/><category term="protonation"/><summary type="html"><![CDATA[Announcement of 200~Protonation Optimizer]]></summary></entry></feed>